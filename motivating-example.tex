\section{Motivating Example}
\label{sec:motivating-example}

In this section, we illustrate how our \textsc{MockDetector} tool finds a mock object created within a unit test case. Our tool identifies variables which have been assigned an object flowing from a mock creation site either through a forward flow may analysis (Soot-based analysis) or through specified declarative constraints (Doop-based analysis).

% explain focal methods first.

To motivate our work, consider Listing~\ref{lis:mockCall}, which presents a unit test case from the Maven project. Line 8 calls \textit{getRequest()}, invoking it on the mock object \textsc{session}. Line 12 then calls \textit{getToolchainsForType()}---this is the actual focal method whose behaviour is being tested. At the bytecode level, the two method invocations are indistinguishable with respect to mockness; to our knowledge, current static analysis tools cannot easily tell the difference between the method invocation on a mocked object on line 8 and the method invocation on a real object on line 12. This uncertainty would confound, for instance, a naive static analysis that attempts to identify focal methods.

Meanwhile, during the construction of \textsc{MockDetector}, we have seen several cases where mocked objects are stored in a container such as an array or a collection. Listing~\ref{lis:container} illustrates the unit test case \textit{canCreateCompositeAnnotator()} selected from jsonschema2pojo, where \textsc{CompositeAnnotator} has an array field annotators, which holds two mock \textsc{Annotator} object after line 9. In this example, our tool would first detect if the statement containing ArrayRef, and it would gather the Locals or FieldRefs. The tool then check if any of these Locals or FieldRefs have already been marked as a mayMock in the analysis, and the tool would mark the definition box of the ArrayRef as arrayMock, meaning the mockiness has propagated to this array container. 

\lstset{language=java,
	keywordstyle=\color{blue}\bfseries,
	commentstyle=\color{green},
	stringstyle=\ttfamily\color{red!50!brown},
	showstringspaces=false}â€Ž
\lstset{literate=%
	*{0}{{{\color{red!20!violet}0}}}1
	{1}{{{\color{red!20!violet}1}}}1
	{2}{{{\color{red!20!violet}2}}}1
	{3}{{{\color{red!20!violet}3}}}1
	{4}{{{\color{red!20!violet}4}}}1
	{5}{{{\color{red!20!violet}5}}}1
	{6}{{{\color{red!20!violet}6}}}1
	{7}{{{\color{red!20!violet}7}}}1
	{8}{{{\color{red!20!violet}8}}}1
	{9}{{{\color{red!20!violet}9}}}1
}

\begin{lstlisting}[basicstyle=\ttfamily, caption={This code snippet illustrates an example from maven-core, where both the focal method, and a method invocation on a mocked object are both presented in the unit test case \textit{testMisconfiguredToolchain()}},
basicstyle=\scriptsize\ttfamily,language = Java, framesep=4.5mm,
framexleftmargin=1.0mm, captionpos=b, xleftmargin=3.5ex, label=lis:mockCall]

@Test
public void testMisconfiguredToolchain() throws Exception {
	// prepare
	MavenSession session = mock( MavenSession.class );
	MavenExecutionRequest req = 
		new DefaultMavenExecutionRequest();
	when( session.getRequest() ).thenReturn( req );
	
	// execute
	ToolchainPrivate[] basics =
	 	toolchainManager.getToolchainsForType("basic", session);
	
	// verify
	assertEquals( 0, basics.length );
}

\end{lstlisting}

\begin{lstlisting}[basicstyle=\ttfamily, caption={This example illustrates an array container holding mock objects from test case \textit{canCreateCompositeAnnotator()}.},
basicstyle=\scriptsize\ttfamily,language = Java, framesep=4.5mm,
framexleftmargin=1mm, captionpos=b, xleftmargin=3.5ex, label=lis:container]

@Test
public void canCreateCompositeAnnotator() {

	Annotator annotator1 = mock(Annotator.class);
	Annotator annotator2 = mock(Annotator.class);
	
	CompositeAnnotator composite = 
		factory.getAnnotator(annotator1, annotator2);
	
	assertThat(composite.annotators.length, equalTo(2));
	assertThat(composite.annotators[0], is(equalTo(annotator1)));
	assertThat(composite.annotators[1], is(equalTo(annotator2)));

}

\end{lstlisting}
