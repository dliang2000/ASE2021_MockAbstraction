\section{Motivating Example}
\label{sec:motivating-example}

In this section, we illustrate how \textsc{MockDetector} finds a mock object created within a unit test case. Our tool identifies variables which have been assigned an object flowing from a mock creation site either using a forward dataflow may-analysis (Soot-based analysis) or by solving specified declarative constraints (Doop-based analysis).

% explain focal methods first.

To motivate our work, consider Listing~\ref{lis:mockCall}, which presents a unit test case from the Maven project. Line 8 calls \textit{getRequest()}, invoking it on the mock object \texttt{session}. Line 12 then calls \textit{getToolchainsForType()}---this is the actual focal method whose behaviour is being tested. At the bytecode level, the two method invocations are indistinguishable with respect to mockness; to our knowledge, current static analysis tools cannot easily tell the difference between the method invocation on a mock object on line~\ref{line:mock} and the method invocation on a real object on line~\ref{line:real}. An IDE with information about mock invocations could provide better suggestions around it. And the uncertainty would confound a naive static analysis that attempts to identify focal methods. For instance, Ghafari et al~\cite{ghafari15:_autom}'s heuristic would fail on this test, as it returns the last mutator method in the object under test, and the focal method here is an accessor. 


\textsc{MockDetector} maintains an abstraction mapping values (local variables or field references) in the Jimple intermediate representation (IR) to \texttt{MockStatus}, which holds three bits monitoring each value's status being a mock, a mock-containing array, and a mock-containing collection, respectively.

Figure~\ref{fig:mockInvocationIllustration} shows how our analysis tool marks mock calls as not being potential focal method calls. Assuming we begin with an empty abstraction before line 2. For the object creation on line 2, since the \textit{Object()} constructor is not a Mock API, \texttt{object1} is not considered as a mock object. It is worth noting that our abstraction would not store \texttt{object1}'s Jimple IR with MockStatus's mock bit set to 0, but rather it is for demonstration purpose. When we iterate to line 5, as \texttt{object1}'s Jimple IR could not be found in the abstraction, we could not eliminate the possibility of method \textit{foo()} invoked on \texttt{object1} being the focal method.

On the other hand, our tool locates the mock-creation API, \textit{java.lang.Object mock(java.lang.Class)} on line 8, and the abstraction will store the mapping of \texttt{object2}'s Jimple IR to MockStatus with the mock bit set to 1. When it iterates to line 11, as \texttt{object2}'s Jimple IR could be found in the abstraction's key set,  with the mock bit being 1, \textsc{MockDetector} will deduce that method \textit{foo()} on line 11 cannot be a focal method, and stores the method's signature, along the class and line number where it is invoked, into an array list, named \textsc{NonFocalMethodList}. 


While we were designing \textsc{MockDetector}, we observed several cases where developers store mock objects in arrays and collections. Listing~\ref{lis:container} presents method \textit{setUp()} in class \texttt{NodeListIteratorTest.java} from commons-collections-4.4, where line \ref{line:storeMocksInArray} puts the mock \texttt{Node} objects in the array-typed field \texttt{nodes}, which is later used in test cases. To find arrays containing mock objects, our analysis would first locate assignment statements containing array references, and would gather all the local variables or field references which appear as sources in these statements. It then checks whether any of these local variables or field reference sources have been marked as mock objects in the analysis. If so, then the tool would mark the local variable or field reference representing the array as an array mock---it propagates the mockness to this array container.


Figure~\ref{fig:arrayMockIllustration} illustrates the process of identifying a mock-containing array. As \textsc{MockDetector} finds a Mock API on line 2, it stores \texttt{object1}'s Jimple IR with MockStatus setting mock bit to 1 into the abstraction. When analysis iterates to line 5, \textsc{MockDetector} finds an array reference, along with \texttt{object1} stored in the array at right hand side of the assignment statement. It finds \texttt{object1}'s Jimple IR in the abstraction's key set, with the mock bit turned on. It can now deduce that \textsc{objects} at the left hand side must represent an array container holding at least one mock object. Therefore, \textsc{MockDetector} puts \textsc{objects}' Jimple IR mapped to a MockStatus setting mock-containing array bit (named arrayMock flag) turned on into the abstraction. 

\lstset{language=java,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green},
    stringstyle=\ttfamily\color{red!50!brown},
        showstringspaces=false}
\lstset{literate=%
    *{0}{{{\color{red!20!violet}0}}}1
    {1}{{{\color{red!20!violet}1}}}1
    {2}{{{\color{red!20!violet}2}}}1
    {3}{{{\color{red!20!violet}3}}}1
    {4}{{{\color{red!20!violet}4}}}1
    {5}{{{\color{red!20!violet}5}}}1
    {6}{{{\color{red!20!violet}6}}}1
    {7}{{{\color{red!20!violet}7}}}1
    {8}{{{\color{red!20!violet}8}}}1
    {9}{{{\color{red!20!violet}9}}}1
}

\begin{lstlisting}[basicstyle=\ttfamily, caption={This code snippet illustrates an example from maven-core, where both the focal method \texttt{getToolchainsForType} and a method invocation \texttt{getRequest} on a mock object occur in test \textit{testMisconfiguredToolchain()}},
basicstyle=\scriptsize\ttfamily,language = Java, framesep=4.5mm, escapechar=|,
framexleftmargin=1.0mm, captionpos=b, xleftmargin=3.5ex, label=lis:mockCall]
@Test
public void testMisconfiguredToolchain()
                 throws Exception {
    MavenSession session = mock( MavenSession.class );
    MavenExecutionRequest req = 
        new DefaultMavenExecutionRequest();
    when( session.getRequest() ).thenReturn( req ); |\label{line:mock}|
    
    ToolchainPrivate[] basics =
         toolchainManager.getToolchainsForType("basic", session); |\label{line:real}|
    
    assertEquals( 0, basics.length );
}
\end{lstlisting}

\begin{lstlisting}[basicstyle=\ttfamily, caption={This example illustrates a field array container holding mock objects from \textit{setup()} in \texttt{NodeListIteratorTest.java}.},
basicstyle=\scriptsize\ttfamily,language = Java, framesep=4.5mm, framexleftmargin=1.0mm, captionpos=b, xleftmargin=3.5ex, label=lis:container, escapechar=|]
// Node array to be filled with mock Node instances
private Node[] nodes;

@Test
protected void setUp() throws Exception {
    // ...

    // create mock Node Instances and 
    // fill Node[] to be used by test cases
    final Node node1 = createMock(Element.class);
    final Node node2 = createMock(Element.class);
    final Node node3 = createMock(Text.class);
    final Node node4 = createMock(Element.class);
    nodes = new Node[] {node1, node2, node3, node4}; |\label{line:storeMocksInArray}|
    // ...
}
\end{lstlisting}


\begin{figure}
    \includegraphics[width=.25\textwidth]{Images/mockInvocationIllustration.png}
    
    \caption{Illustration of the process locating mock object and determining mock calls.}
    \label{fig:mockInvocationIllustration}
    
\end{figure}

\begin{figure}
    \includegraphics[width=.25\textwidth]{Images/arrayMockIllustration.png}
    
    \caption{Illustration of the process determining array that is an arrayMock.}
    \label{fig:arrayMockIllustration}
    
\end{figure}
