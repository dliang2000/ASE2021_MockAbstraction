\section{Technique}
\label{sec:technique}

We present two complementary ways of statically computing mock information: an imperative implementation of a dataflow analysis (using the Soot~\cite{Vallee-Rai:1999:SJB:781995.782008} program analysis framework), as well as a declarative implementation (using the Doop~\cite{conf/oopsla/BravenboerS09} framework). While the core analysis is the same, the different implementation technologies have different affordances. For instance, it is easier to mark a field as mock-containing in Doop than in Soot. In Section~\ref{sec:evaluation}, we compare the results obtained using each technology.

\subsection{Common Infrastructure}
We have parameterized our technique with respect to mocking libraries and have instantiated it with respect to the popular Java libraries Mockito\footnote{\url{https://site.mockito.org/}}, EasyMock\footnote{\url{https://easymock.org/}}, and PowerMock\footnote{\url{https://github.com/powermock/powermock}}. We also support different versions of JUnit\footnote{\url{https://junit.org}}: 3, and 4+. We discuss the parameterization in this subsection.

Both JUnit and mocking libraries are highly-reflective and would normally pose problems for static analyses. Fortunately, they use reflection in limited, stylized ways, and we have designed our analyses to soundly handle these libraries.

\paragraph{JUnit}
JUnit tests are simply methods that developers write in test classes, appropriately annotated (in JUnit 3 by method name starts with "test", in 4+ by a @Test annotation). A JUnit test runner uses reflection to find tests. Out of the box, static analysis engines do not perceive tests as reachable code.

% what about hierarchical drivers?

To enable static analysis over the test suite classes, our tool uses Soot to generate a driver class for each sub-package. In each of these sub-package driver classes, we create a \textit{runall()} method, which invokes all methods within the sub-package that JUnit (either 3 or 4) considers to be public, non-constructor test cases, surrounded by calls to class-level init/setup and teardown methods. Concrete test methods are particularly easy to call from a driver, as they are specified to have no parameters and are not supposed to rely on any particular ordering. 
Our tool then creates a RootDriver class at the root package level, which would invoke \textit{runall()} method in each sub-package driver class, along with invocations on the Test/Before/After methods created in the classes located on the root level. The drivers that we generate also contains code to catch all checked exceptions declared to be thrown by the unit tests. The generated driver classes are used by both Soot and Doop implementations of the analysis.

\paragraph{Mock Libraries}
Our supported mock libraries take different approaches to declaring mocks. All of the libraries have methods that generate mock objects; for instance, EasyMock contains the \texttt{createMock()} method. We consider return values from these methods to be mock objects. Additionally, Mockito contains a fluent \texttt{verify()} method which returns a mock object. Finally, Mockito also allows developers to mark fields as \texttt{@Mock}; we treat reads from such fields as mock objects. Both implementations start the analysis by hard coding these facts on mock source methods from the mock libraries' documentation. 

\subsection{Soot Implementation}
In this section, we describe the imperative dataflow analysis (Soot-based) technique that \textsc{MockDetector} applies to find unit test cases with mock objects created in the test body. Our tool tracks the creation sites and occurrences of the mock object through forward flow may analysis, meaning the evaluation of mockness would hold true as long as the variable is a mock on any path. It also looks into containers like array or Collection, and check if the container holds any may mock object. It treats as the mockness has propagated to the container if it indeed holds may mock object.

% Mock Libraries discussed in Common Infrastructure section
%\paragraph{Define Common Mocking Library APIs}
%\label{subsubsec:collection}

%Our tool stores a pool of common APIs, provided by the analysis designer, which are used to create mock objects when using popular Java mocking libraries, including Mockito, EasyMock, and PowerMock. These APIs are the possible mock creation sites, where the locals/variables holding mock objects are first created.

%Given a pool of possible APIs to search for, our tool may analyze tests for their usage of these APIs.% Facts for mock source methods is discussed in doop, maybe this part could be discussed once to avoid repetition?


\paragraph{Forward May Analysis}
\label{subsubsec:forward}

To solve the problem, our tool uses forward may analysis, where it analyzes statements from top to bottom, and to keep variables that are verified to be mocks on any possible path at merged points. \textsc{MockDetector} uses the abstraction 

\begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none]
Map<Unit, Map<Value, MockStatus>>
\end{lstlisting}
to maintain the mock information for local variables or field references in the flow (represented by Value in Soot). \texttt{MockStatus} is a class holding three bits, each representing the status of "May Mock", "Array Mock", and "Collection Mock", respectively, with the restriction of at most one bit being 1. Such abstraction would have each Unit $\times$ Value combination mapping to one MockStatus.

\textsc{MockDetector} uses may analysis for two reasons: first, for one variable, programmers rarely make it a real object in one branch, and a mock object in a different branch; second, such approximation would not impose issue towards focal methods finding, since a method invoked on a "may" mock object defined in one path, would unlikely be a focal method in a unit test. 

\textsc{MockDetector} implements the "may" logic in the following manner: it checks the two in-flows 
of \begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none]
Map<Value, MockStatus>
\end{lstlisting}
from two paths. For any variable that is only stored in one map, the key-value pair is directly passed to the out-flow map. For a variable that is a shared key of the two maps, the analysis would update the out-flow's MockStatus by applying the "OR" operation on the "May Mock", "Array Mock", and "Collection Mock" bits from the MockStatus value retrieved from both in-flow maps. 

For each statement in a forward flow analysis, we consider two sets: generated set and killed set. In this study, the first set contains the locals that are judged to become mocks, whereas the killed set containing locals that are determined to no longer to be mocks. Equations (1) and (2) illustrates how the inflow and outflow are defined and calculated for each unit: $In(u)$, representing a program point before executing $u$, is the intersection of all outflows after executing each element in immediate predecessor statements of $u$; $Out(u)$, on the other hand, is determined by first removing the killed set from $In(u)$, and union the result with generated set. 

\begin{equation}
\mathrm{In}(u) = \bigcap_{u' \in preds(u)} \mathrm{Out}(u') 
\end{equation}

\begin{equation}
\mathrm{Out}(u) = (\mathrm{In}(u) - \mathrm{Kill}(u)) \bigcup \mathrm{Gen}(u) 
\end{equation}

In our analysis, the generated set consists of two steps. Consider the statement: 
\begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none]
Employee employee = mock(Employee.class);
\end{lstlisting}
The intermediate representation generated in Jimple format would be:
\begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none]
$r1 = staticinvoke <org.mockito.Mockito: 
java.lang.Object mock(java.lang.Class)>
(class "Lca/liang/Employee;")

r2 = (ca.liang.Employee) $r1
\end{lstlisting}

In this example, $\$r1$ is the immediate receiver from Mockito's mock creation site, whereas $r2$ is the casted expression that gets carried along in the subsequent program. Thus, our tool would include the immediate receivers, and the casted expressions of mock objects into the generation set, in two steps. 

\paragraph{Special support for containers} Several benchmarks use arrays or collection objects to hold mock objects. In this scenario, our tool would consider that mockness has been passed along to the container. Taking an array as an example, our tool would first look for an array reference in the executing statement, meaning there is a read or a write from an array. Then, \textsc{MockDetector} would look for variables to be stored into the array, and check whether any of the variables have been found to be mocks. If so, it would label the array as "ArrayMock".

A similar process is applied to Collection. The main difference is Collection has multiple sub-types that may store objects in different manners. \textsc{MockDetector} resolves this problem by first holding a pool of reading and writing method APIs associated with each sub-type of Collection. It subsequently checks if any sub-type of collection are present in the statement, which could be done by checking the hierarchy for each variable. If a collection sub-type container is presented, \textsc{MockDetector} would then check if a STORE effect is applied to the container, indicating some object is to be stored in the container. Once the object is determined "MayMock", the collection container variable would immediately be labelled as "CollectionMock".\\

\paragraph{Pre-Analysis for Field Mocks Defined in Default Init and Before Methods}
\label{subsubsec:pre-analysis} This is the paragraph to discuss about the pre-analysis on field mocks.


\begin{lstlisting}[basicstyle=\ttfamily, caption={Example for Annotated field mocks from \texttt{DefaultToolchainManagerTest.java} in maven-core.},
basicstyle=\scriptsize\ttfamily,language = Java, framesep=4.5mm,
framexleftmargin=1mm, captionpos=b, xleftmargin=3.5ex, label=lis:annotatedMock]

public class DefaultToolchainManagerTest
{

	@Mock
	private Logger logger;
	
	@Mock
	private ToolchainFactory toolchainFactory_basicType;
	
	@Mock
	private ToolchainFactory toolchainFactory_rareType;
	
	@Before
	public void onSetup() throws Exception
	{	
		...
		MockitoAnnotations.initMocks( this );
		...
	}

}

\end{lstlisting}

\begin{lstlisting}[basicstyle=\ttfamily, caption={Example for field mocks defined in <init> from \texttt{TypeRuleTest.java} in jsonschema2pojo.},
basicstyle=\scriptsize\ttfamily,language = Java, framesep=4.5mm,
framexleftmargin=1mm, captionpos=b, xleftmargin=3.5ex, label=lis:fieldMock]

public class TypeRuleTest {

	private GenerationConfig config 
				= mock(GenerationConfig.class);
	private RuleFactory ruleFactory 
				= mock(RuleFactory.class);
	...
}

\end{lstlisting}

\begin{lstlisting}[basicstyle=\ttfamily, caption={Example for field mocks defined in Before method from \texttt{PayRollMockTest.java} in microbenchmark.},
basicstyle=\scriptsize\ttfamily,language = Java, framesep=4.5mm,
framexleftmargin=1mm, captionpos=b, xleftmargin=3.5ex, label=lis:fieldMock2]

public class PayRollMockTest {
	private EmployeeDB employeeDB;
	private BankService bankService;
	
	@Before
	public void init() {
		...
		employeeDB = mock(EmployeeDB.class);
		bankService = mock(BankService.class);
		...
	}
}

\end{lstlisting}

\subsection{Doop Implementation}
We next describe the declarative Doop-based technique that \textsc{MockDetector} uses. Similarly to the dataflow analysis, the declarative approach propagates mockness from known mock sources, through the statements in the intermediate representation, to potential mock invocation sites.

% Mock Libraries discussed in Common Infrastructure section, perhaps refer to the paragraph in Common Infrastructure section?
The core of the implementation starts by declaring facts for 9 mock source methods manually gleaned from the mock libraries' documentation, as specified through method signatures (e.g. 
\texttt{<org.mockito.Mockito: java.lang.Object mock(java.lang.Class)>}.)
It then declares that a variable {\tt v} satisfies \verb+isMockVar(v)+ if it is assigned from the return value of a mock source, or otherwise traverses the program's interprocedural control-flow graph, through assignments, which may possibly flow through fields, collections, or arrays. Finally, an invocation site is a mock invocation if the receiver object {\tt v} satisfies \verb+isMockVar(v)+. Listing~\ref{lst:core} presents the core rules for {\tt isMockVar}.

\begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none,label={lst:core},caption={Core rules for propagating mockness via predicate {\tt isMockVar}.}]
    .decl isMockVar(v: Var)
    isMockVar(v) :-
      AssignReturnValue(mi, v),
      callsMockSource(mi).
    isMockVar(v) :-
      isMockVar(from),
      AssignCast(_ /* type */, from, 
                 v, _ /* inmethod */).
    isMockVar(v) :-
      isMockVar(v1),
      AssignLocal(v1, v, _).
\end{lstlisting}

We designed the analysis in a modular fashion, such that the interprocedural, collections, arrays, and fields support can all be disabled through the use of \verb+#ifdef+s, which can be specified on the Doop command-line.

\paragraph{Interprocedural support} From our perspective, including interprocedural support is almost trivial; we only need to add the line 
\begin{lstlisting}[basicstyle=\ttfamily\small,numbers=none]
  mainAnalysis.CallGraphEdge(_, mi, _, callee)
\end{lstlisting}
stating that there is a call graph edge between the method invocation {\tt mi} and its callee {\tt callee}. We chose to run our analysis on top of Doop's context-insensitive analysis, but that can be easily changed via command-line option.

\paragraph{Arrays} Consistent with our analysis being a may-analysis, we use predicate {\tt isArrayLocalThatContainsMocks} to record local variables pointing to arrays that may contain mock objects. This predicate is true whenever the program under analysis stores a mock variable into an array; we also transfer array-mockness through assignments and casts. When a local variable is read from a mock-containing array, then the local variable itself is marked as a mock variable.

\paragraph{Fields} Apart from the obvious rule stating that a field which is assigned from a mock satisfies {\tt fieldContainsMock}, we also label fields that have the {\tt org.mockito.Mock} annotation as mock-containing. We declare that a given field \emph{signature} may contain a mock, i.e. the field with a given signature belonging to all objects of a given type.

\paragraph{Arrays and Fields} We also support not just array locals but also array fields. That is, when an array-typed field is assigned from a mock-containing array local, then it is also a mock. And when an array-typed local variable is assigned from a mock-containing array field, then that array local is a mock.

\paragraph{Containers} We support containers the same way we support arrays, except that we hardcode all relevant methods from the Java Collections API. There are 60 such methods in total, which together account for about 1/6th of our Doop analysis. In addition to straightforward get and put methods, we also support iterators, add-all methods, and collection copies via constructors. We also handle {\tt toArray} by propagating mockness from the collection to the array.

We also support containers stored in fields.

% TODO compare with taint analysis
