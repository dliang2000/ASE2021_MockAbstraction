\section{Evaluation}
\label{sec:evaluation}

\begin{table*}[b]
	\centering
	\caption{Counts of unit test cases containing MustMock object, counts of unit test cases with array containing mock, and counts of unit test cases with collection containing mock in the 3 benchmarks.}
	%	\begin{adjustbox}{width=0.1\textwidth}
	\begin{tabular}{lrrrr}
		\toprule
		Benchmark & \# of Test Cases & \# of MustMock Cases  & \# of ArrayMock Cases & \# of CollectionMock Cases \\
		\midrule
		commons-collections           			&  24747       &  3   & 1 & 0       \\
		micro-benchmark         		  		&  22    &  14   & 4 & 2       \\
		mybatis\_3.5.6         		  		&  1675    &  324   & 2 & 0       \\
		
		quartz-core         	  			&  305     &  7   & 0 & 0      \\
		\bottomrule
	\end{tabular}
	%	\end{adjustbox}
	\label{tab:mocks}
\end{table*}

The goal of our study is to correctly identify and trace mock objects in the test suite. To this end, we conduct quantitative and qualitative research focusing on two research questions:

\begin{quote}
	\emph{RQ 1: Are the mocks correctly identified and traced for each test method?}
\end{quote}

\begin{quote}
	\emph{RQ 2: Would this be helpful for existing static analysis tools?}
\end{quote}

\subsection{Quantitative Analysis}
\label{subsec:effectiveness}

Currently, our tool has tested a suite of three benchmarks intraprocedurally. Table~\ref{tab:mocks} has shown the number of test cases, and number of cases holding MustMock, ArrayMock, and CollectionMocks. Manual inspection of the test cases in micro-benchmark has so far indicates that our tool can correctly identify the objects or containers with mockiness. 

There are more test cases holding inter-procedural mocks (i.e., the mock object is created in a helper method and passed into the test case) in commons-collections and micro-benchmark. The inter-procedural analysis is currently in development and will be discussed in Section~\ref{sec:conclusion}.

The Procedure Summaries produced after the analysis has indicated that the tracing of "mockiness" of variables and containers is also correct through the whole program. 

\subsection{Application}
\label{subsec:static}

The accuracy results in tracing intra-procedural mock objects or containers have indicated that \textsc{MockDetector} has the potential to be applied as a helper for existing static analysis tools. By adding proper adjustment, it could pass the mock information to the static analysis, so that the generated call graph may appropriately omit the methods invoked on mocked objects, thus increasing its accuracy.

By running evaluation (also inter-procedurally) on more benchmarks, our tool would have the potential to finding the scenario where developers prefer using mocked objects for dependencies, and subsequently providing mock suggestions.